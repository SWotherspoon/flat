makeK <- function(h) {
  n <- length(h)+1L
  K <- matrix(0,n,n)
  K[seq.int(1L,n*n,n+1L)] <- c(h/3,0)+c(0,h/3)
  K[seq.int(2L,n*n,n+1L)] <- h/6
  K[seq.int(n+1L,n*n,n+1L)] <- h/6
  K
}

makeBfb <- function(h) {
  n <- length(h)+1L
  hm <- hp <- h
  hm[1L] <- -hm[1L]
  B <- matrix(0,n,n)
  B[seq.int(1L,n*n,n+1L)] <- c(hm/3,0)+c(0,hp/3)
  B[seq.int(2L,n*n,n+1L)] <- hp/6
  B[seq.int(n+1L,n*n,n+1L)] <- hm/6
  B
}

makeDfb <- function(h) {
  n <- length(h)+1L
  qm <- qp <- 1/h
  qm[1L] <- -qm[1L]
  D <- matrix(0,n,n)
  D[seq.int(1L,n*n,n+1L)] <- c(-qm,0)+c(0,-qp)
  D[seq.int(2L,n*n,n+1L)] <- qp
  D[seq.int(n+1L,n*n,n+1L)] <- qm
  D
}


##' Penalized cubic regression splines constrained to have zero first
##' derivative at the leftmost and rightmost knots.
##'
##' These smooths are similar to the standard "cr" smooths, except
##' that the first derivative is constrained to be zero at the
##' leftmost and rightmost knots. Because the location at which the
##' derivative constraint is applied is determined by the knots, the
##' knots cannot be automatically chosen and must be supplied by the
##' user.
##'
##' Similar to the unconstrained case, the penalty smooth in the
##' presence of constraints on the first derivative can be shown to be
##' a cubic spline but with discontinuities in the second derivative
##' at the points where the derivative constraints apply.
##'
##' In this implementation the roughness penalty is only applied on
##' the region spanned by the knots.  Outside this region the smooth
##' is defined by extrapolation assuming the second derivative is
##' continuous.
##'
##' @title Flat End Penalized Cubic Regression Splines
##' @param object a smooth specification object, usually generated by
##'   a term `s(...,bs="fb",...)`
##' @param data a list containing just the data (including any by
##'   variable) required by this term, with names corresponding to
##'   `object$term` and `object$by`. The `by` variable
##'   must be the last element.
##' @param knots a list containing any knots supplied for basis setup
##'   in same order and with same names as `data`. Cannot be
##'   `NULL`.
##' @return An object of class "fb.smooth", containing the elements of a
##'   smooth class documented under [mgcv::smooth.construct()].
##' @importFrom mgcv smooth.construct
##' @export
smooth.construct.fb.smooth.spec <- function(object,data,knots) {

  if(length(object$term)!=1L)
    stop("Basis only handles 1D smooths")
  x <- data[[object$term]]
  nx <- length(x)
  k <- sort(knots[[object$term]])
  nk <- length(k)

  if(nk<=3L) stop("At least 3 knots must be supplied")
  object$bs.dim <- nk

  h <- k[-1L]-k[-nk]
  F <- solve(makeBfb(h),makeDfb(h))
  j <- findInterval(x,k,all.inside=TRUE)
  X <- matrix(0,nx,nk)
  X[cbind(seq_len(nx),j)] <- (k[j+1L]-x)/h[j]
  X[cbind(seq_len(nx),j+1L)] <- (x-k[j])/h[j]
  cm <- ((k[j+1L]-x)^3/h[j]-h[j]*(k[j+1L]-x))/6
  cp <- ((x-k[j])^3/h[j]-h[j]*(x-k[j]))/6
  X <- X+cm*F[j,]+cp*F[j+1L,]

  object$X <- X
  object$S <- list()
  if(!object$fixed) {
    object$S[[1L]] <- t(F)%*%makeK(h)%*%F
  }
  object$rank <- nk-2L
  object$null.space.dim <- 2L
  object$knots <- k
  object$df <- ncol(object$X)
  class(object) <- "fb.smooth"
  object
}

##' A method for [mgcv::Predict.matrix()] for penalized cubic
##' regression splines smooths.
##'
##' This method constructs a prediction matrix for penalized cubic
##' regression splines smooths constrained to have zero first
##' derivative at the leftmost and rightmost knots.
##'
##' @title GAM Predict Matrix Method
##' @param object a smooth object, usually generated by a
##'   [mgcv::smooth.construct()] method having processed a smooth
##'   specification object generated by an [mgcv::s()] or
##'   [mgcv::te()] term in a [mgcv::gam()] formula.
##' @param data A data frame containing the values of the (named)
##'   covariates at which the smooth term is to be evaluated. Exact
##'   requirements are as for [mgcv::smooth.construct()]
##' @return A matrix mapping the coefficients for the smooth term to its
##'   values at the supplied data values.
##' @importFrom mgcv Predict.matrix
##' @export
Predict.matrix.fb.smooth <- function(object,data) {

  x <- data[[object$term]]
  nx <- length(x)
  k <- object$knots
  nk <- length(k)

  h <- k[-1L]-k[-nk]
  F <- solve(makeBfb(h),makeDfb(h))
  j <- findInterval(x,k,all.inside=TRUE)
  X <- matrix(0,nx,nk)
  X[cbind(seq_len(nx),j)] <- (k[j+1L]-x)/h[j]
  X[cbind(seq_len(nx),j+1L)] <- (x-k[j])/h[j]
  cm <- ((k[j+1L]-x)^3/h[j]-h[j]*(k[j+1L]-x))/6
  cp <- ((x-k[j])^3/h[j]-h[j]*(x-k[j]))/6
  X <- X+cm*F[j,]+cp*F[j+1L,]
  X
}


##' Penalized cubic regression splines constrained to have zero first
##' derivative at the leftmost and rightmost knots.
##'
##' These smooths are similar to the standard "cr" smooths, except
##' that the first derivative is constrained to be zero at the
##' leftmost and rightmost knots. Because the location at which the
##' derivative constraint is applied is determined by the knots, the
##' knots cannot be automatically chosen and must be supplied by the
##' user.
##'
##' Similar to the unconstrained case, the penalty smooth in the
##' presence of constraints on the first derivative can be shown to be
##' a cubic spline but with discontinuities in the second derivative
##' at the points where the derivative constraints apply.  So the
##' smooth will be a cubic spline within the interval spanned by the
##' knots, will be linear outside this interval and have
##' discontinuous second derivatives on the boundary.
##'
##' @title Flat End Penalized Cubic Regression Splines
##' @param object a smooth specification object, usually generated by
##'   a term `s(...,bs="fb",...)`
##' @param data a list containing just the data (including any by
##'   variable) required by this term, with names corresponding to
##'   `object$term` and `object$by`. The `by` variable
##'   must be the last element.
##' @param knots a list containing any knots supplied for basis setup
##'   in same order and with same names as `data`. Cannot be
##'   `NULL`.
##' @return An object of class "fb.smooth", containing the elements of a
##'   smooth class documented under [mgcv::smooth.construct()].
##' @importFrom mgcv smooth.construct
##' @export
smooth.construct.zb.smooth.spec <- function(object,data,knots) {

  if(length(object$term)!=1L)
    stop("Basis only handles 1D smooths")
  x <- data[[object$term]]
  nx <- length(x)
  k <- sort(knots[[object$term]])
  nk <- length(k)

  if(nk<=3L) stop("At least 3 knots must be supplied")
  object$bs.dim <- nk

  h <- k[-1L]-k[-nk]
  F <- solve(makeBfb(h),makeDfb(h))
  j <- findInterval(x,k,all.inside=TRUE)
  X <- matrix(0,nx,nk)
  x <- pmin(k[nk],pmax(k[1L],x))
  X[cbind(seq_len(nx),j)] <- (k[j+1L]-x)/h[j]
  X[cbind(seq_len(nx),j+1L)] <- (x-k[j])/h[j]
  cm <- ((k[j+1L]-x)^3/h[j]-h[j]*(k[j+1L]-x))/6
  cp <- ((x-k[j])^3/h[j]-h[j]*(x-k[j]))/6
  X <- X+cm*F[j,]+cp*F[j+1L,]

  object$X <- X
  object$S <- list()
  if(!object$fixed) {
    object$S[[1L]] <- t(F)%*%makeK(h)%*%F
  }
  object$rank <- nk-2L
  object$null.space.dim <- 2L
  object$knots <- k
  object$df <- ncol(object$X)
  class(object) <- "zb.smooth"
  object
}

##' A method for [mgcv::Predict.matrix()] for penalized cubic
##' regression splines smooths.
##'
##' This method constructs a prediction matrix for penalized cubic
##' regression splines smooths constrained to have zero first
##' derivative at the leftmost and rightmost knots.
##'
##' @title GAM Predict Matrix Method
##' @param object a smooth object, usually generated by a
##'   [mgcv::smooth.construct()] method having processed a smooth
##'   specification object generated by an [mgcv::s()] or
##'   [mgcv::te()] term in a [mgcv::gam()] formula.
##' @param data A data frame containing the values of the (named)
##'   covariates at which the smooth term is to be evaluated. Exact
##'   requirements are as for [mgcv::smooth.construct()]
##' @return A matrix mapping the coefficients for the smooth term to its
##'   values at the supplied data values.
##' @importFrom mgcv Predict.matrix
##' @export
Predict.matrix.zb.smooth <- function(object,data) {

  x <- data[[object$term]]
  nx <- length(x)
  k <- object$knots
  nk <- length(k)

  h <- k[-1L]-k[-nk]
  F <- solve(makeBfb(h),makeDfb(h))
  j <- findInterval(x,k,all.inside=TRUE)
  X <- matrix(0,nx,nk)
  x <- pmin(k[nk],pmax(k[1L],x))
  X[cbind(seq_len(nx),j)] <- (k[j+1L]-x)/h[j]
  X[cbind(seq_len(nx),j+1L)] <- (x-k[j])/h[j]
  cm <- ((k[j+1L]-x)^3/h[j]-h[j]*(k[j+1L]-x))/6
  cp <- ((x-k[j])^3/h[j]-h[j]*(x-k[j]))/6
  X <- X+cm*F[j,]+cp*F[j+1L,]
  X
}



makeBfl <- function(h) {
  n <- length(h)+1L
  hm <- hp <- h
  hm[1L] <- -hm[1L]
  hp[length(hp)] <- 0
  B <- matrix(0,n,n)
  B[seq.int(1L,n*n,n+1L)] <- c(hm/3,1)+c(0,hp/3)
  B[seq.int(2L,n*n,n+1L)] <- hp/6
  B[seq.int(n+1L,n*n,n+1L)] <- hm/6
  B
}

makeDfl <- function(h) {
  n <- length(h)+1L
  qm <- qp <- 1/h
  qm[1L] <- -qm[1L]
  qp[length(qp)] <- 0
  D <- matrix(0,n,n)
  D[seq.int(1L,n*n,n+1L)] <- c(-qm,0)+c(0,-qp)
  D[seq.int(2L,n*n,n+1L)] <- qp
  D[seq.int(n+1L,n*n,n+1L)] <- qm
  D
}


##' Penalized cubic regression splines constrained to have zero first
##' derivative at the leftmost knot.
##'
##' These smooths are similar to the standard "cr" smooths, except
##' that the first derivative is constrained to be zero at the
##' leftmost knot. Because the location at which the derivative
##' constraint is applied is determined by the knots, the knots cannot
##' be automatically chosen and must be supplied by the user.
##'
##' Similar to the unconstrained case, the penalty smooth in the
##' presence of constraints on the first derivative can be shown to be
##' a cubic spline but with discontinuities in the second derivative
##' at the points where the derivative constraints apply.
##'
##' In this implementation the roughness penalty is only applied on
##' the region above the leftmost knot.  Outside this region the
##' smooth is defined by extrapolation assuming the second derivative
##' is continuous.
##'
##' @title Flat End Penalized Cubic Regression Splines
##' @param object a smooth specification object, usually generated by
##'   a term `s(...,bs="fl",...)`
##' @param data a list containing just the data (including any by
##'   variable) required by this term, with names corresponding to
##'   `object$term` and `object$by`. The `by` variable
##'   must be the last element.
##' @param knots a list containing any knots supplied for basis setup
##'   in same order and with same names as `data`. Cannot be
##'   `NULL`.
##' @return An object of class "fb.smooth", containing the elements of a
##'   smooth class documented under [mgcv::smooth.construct()].
##' @importFrom mgcv smooth.construct
##' @export
smooth.construct.fl.smooth.spec <- function(object,data,knots) {

  if(length(object$term)!=1L)
    stop("Basis only handles 1D smooths")
  x <- data[[object$term]]
  nx <- length(x)
  k <- sort(knots[[object$term]])
  nk <- length(k)

  if(nk<=3L) stop("At least 3 knots must be supplied")
  object$bs.dim <- nk

  h <- k[-1L]-k[-nk]
  F <- solve(makeBfl(h),makeDfl(h))
  j <- findInterval(x,k,all.inside=TRUE)
  X <- matrix(0,nx,nk)
  X[cbind(seq_len(nx),j)] <- (k[j+1L]-x)/h[j]
  X[cbind(seq_len(nx),j+1L)] <- (x-k[j])/h[j]
  cm <- ifelse(x > k[nk],0,(k[j+1L]-x)^3/(6*h[j]))-h[j]*(k[j+1L]-x)/6
  cp <- ((x-k[j])^3/h[j]-h[j]*(x-k[j]))/6
  X <- X+cm*F[j,]+cp*F[j+1L,]

  object$X <- X
  object$S <- list()
  if(!object$fixed) {
    object$S[[1L]] <- t(F)%*%makeK(h)%*%F
  }
  object$rank <- nk-2L
  object$null.space.dim <- 2L
  object$knots <- k
  object$df <- ncol(object$X)
  class(object) <- "fl.smooth"
  object
}

##' A method for [mgcv::Predict.matrix()] for penalized cubic
##' regression splines smooths.
##'
##' This method constructs a prediction matrix for penalized cubic
##' regression splines smooths constrained to have zero first
##' derivative at the leftmost knot.
##'
##' @title GAM Predict Matrix Method
##' @param object a smooth object, usually generated by a
##'   [mgcv::smooth.construct()] method having processed a smooth
##'   specification object generated by an [mgcv::s()] or
##'   [mgcv::te()] term in a [mgcv::gam()] formula.
##' @param data A data frame containing the values of the (named)
##'   covariates at which the smooth term is to be evaluated. Exact
##'   requirements are as for [mgcv::smooth.construct()]
##' @return A matrix mapping the coefficients for the smooth term to its
##'   values at the supplied data values.
##' @importFrom mgcv Predict.matrix
##' @export
Predict.matrix.fl.smooth <- function(object,data) {

  x <- data[[object$term]]
  nx <- length(x)
  k <- object$knots
  nk <- length(k)

  h <- k[-1L]-k[-nk]
  F <- solve(makeBfl(h),makeDfl(h))
  j <- findInterval(x,k,all.inside=TRUE)
  X <- matrix(0,nx,nk)
  X[cbind(seq_len(nx),j)] <- (k[j+1L]-x)/h[j]
  X[cbind(seq_len(nx),j+1L)] <- (x-k[j])/h[j]
  cm <- ifelse(x > k[nk],0,(k[j+1L]-x)^3/(6*h[j]))-h[j]*(k[j+1L]-x)/6
  cp <- ((x-k[j])^3/h[j]-h[j]*(x-k[j]))/6
  X <- X+cm*F[j,]+cp*F[j+1L,]
  X
}


##' Penalized cubic regression splines constrained to have zero first
##' derivative at the leftmost knot.
##'
##' These smooths are similar to the standard "cr" smooths, except
##' that the first derivative is constrained to be zero at the
##' leftmost knot. Because the location at which the derivative
##' constraint is applied is determined by the knots, the knots cannot
##' be automatically chosen and must be supplied by the user.
##'
##' Similar to the unconstrained case, the penalty smooth in the
##' presence of constraints on the first derivative can be shown to be
##' a cubic spline but with discontinuities in the second derivative
##' at the points where the derivative constraints apply.  So the
##' smooth will be a cubic spline within the interval spanned by the
##' knots, will be linear outside this interval and have
##' discontinuous second derivatives on the left boundary.
##'
##' @title Flat End Penalized Cubic Regression Splines
##' @param object a smooth specification object, usually generated by
##'   a term `s(...,bs="fl",...)`
##' @param data a list containing just the data (including any by
##'   variable) required by this term, with names corresponding to
##'   `object$term` and `object$by`. The `by` variable
##'   must be the last element.
##' @param knots a list containing any knots supplied for basis setup
##'   in same order and with same names as `data`. Cannot be
##'   `NULL`.
##' @return An object of class "fb.smooth", containing the elements of a
##'   smooth class documented under [mgcv::smooth.construct()].
##' @importFrom mgcv smooth.construct
##' @export
smooth.construct.zl.smooth.spec <- function(object,data,knots) {

  if(length(object$term)!=1L)
    stop("Basis only handles 1D smooths")
  x <- data[[object$term]]
  nx <- length(x)
  k <- sort(knots[[object$term]])
  nk <- length(k)

  if(nk<=3L) stop("At least 3 knots must be supplied")
  object$bs.dim <- nk

  h <- k[-1L]-k[-nk]
  F <- solve(makeBfl(h),makeDfl(h))
  j <- findInterval(x,k,all.inside=TRUE)
  X <- matrix(0,nx,nk)
  x <- pmax(k[1L],x)
  X[cbind(seq_len(nx),j)] <- (k[j+1L]-x)/h[j]
  X[cbind(seq_len(nx),j+1L)] <- (x-k[j])/h[j]
  cm <- ifelse(x > k[nk],0,(k[j+1L]-x)^3/(6*h[j]))-h[j]*(k[j+1L]-x)/6
  cp <- ((x-k[j])^3/h[j]-h[j]*(x-k[j]))/6
  X <- X+cm*F[j,]+cp*F[j+1L,]

  object$X <- X
  object$S <- list()
  if(!object$fixed) {
    object$S[[1L]] <- t(F)%*%makeK(h)%*%F
  }
  object$rank <- nk-2L
  object$null.space.dim <- 2L
  object$knots <- k
  object$df <- ncol(object$X)
  class(object) <- "zl.smooth"
  object
}

##' A method for [mgcv::Predict.matrix()] for penalized cubic
##' regression splines smooths.
##'
##' This method constructs a prediction matrix for penalized cubic
##' regression splines smooths constrained to have zero first
##' derivative at the leftmost knot.
##'
##' @title GAM Predict Matrix Method
##' @param object a smooth object, usually generated by a
##'   [mgcv::smooth.construct()] method having processed a smooth
##'   specification object generated by an [mgcv::s()] or
##'   [mgcv::te()] term in a [mgcv::gam()] formula.
##' @param data A data frame containing the values of the (named)
##'   covariates at which the smooth term is to be evaluated. Exact
##'   requirements are as for [mgcv::smooth.construct()]
##' @return A matrix mapping the coefficients for the smooth term to its
##'   values at the supplied data values.
##' @importFrom mgcv Predict.matrix
##' @export
Predict.matrix.zl.smooth <- function(object,data) {

  x <- data[[object$term]]
  nx <- length(x)
  k <- object$knots
  nk <- length(k)

  h <- k[-1L]-k[-nk]
  F <- solve(makeBfl(h),makeDfl(h))
  j <- findInterval(x,k,all.inside=TRUE)
  X <- matrix(0,nx,nk)
  x <- pmax(k[1L],x)
  X[cbind(seq_len(nx),j)] <- (k[j+1L]-x)/h[j]
  X[cbind(seq_len(nx),j+1L)] <- (x-k[j])/h[j]
  cm <- ifelse(x > k[nk],0,(k[j+1L]-x)^3/(6*h[j]))-h[j]*(k[j+1L]-x)/6
  cp <- ((x-k[j])^3/h[j]-h[j]*(x-k[j]))/6
  X <- X+cm*F[j,]+cp*F[j+1L,]
  X
}



makeBfr <- function(h) {
  n <- length(h)+1L
  hm <- hp <- h
  hm[1L] <- 0
  B <- matrix(0,n,n)
  B[seq.int(1L,n*n,n+1L)] <- c(hm/3,0)+c(1,hp/3)
  B[seq.int(2L,n*n,n+1L)] <- hp/6
  B[seq.int(n+1L,n*n,n+1L)] <- hm/6
  B
}

makeDfr <- function(h) {
  n <- length(h)+1L
  qm <- qp <- 1/h
  qm[1L] <- 0
  D <- matrix(0,n,n)
  D[seq.int(1L,n*n,n+1L)] <- c(-qm,0)+c(0,-qp)
  D[seq.int(2L,n*n,n+1L)] <- qp
  D[seq.int(n+1L,n*n,n+1L)] <- qm
  D
}


##' Penalized cubic regression splines constrained to have zero first
##' derivative at the rightmost knot.
##'
##' These smooths are similar to the standard "cr" smooths, except
##' that the first derivative is constrained to be zero at the
##' rightmost knot. Because the location at which the derivative
##' constraint is applied is determined by the knots, the knots cannot
##' be automatically chosen and must be supplied by the user.
##'
##' Similar to the unconstrained case, the penalty smooth in the
##' presence of constraints on the first derivative can be shown to be
##' a cubic spline but with discontinuities in the second derivative
##' at the points where the derivative contraints apply.
##'
##' In this implementation the roughness penalty is only applied on
##' the region below the rightmost knot.  Outside this region the
##' smooth is defined by extrapolation assuming the second derivative
##' is continuous.
##'
##' @title Flat Right End Penalized Cubic Regression Splines
##' @param object a smooth specification object, usually generated by
##'   a term `s(...,bs="fl",...)`
##' @param data a list containing just the data (including any by
##'   variable) required by this term, with names corresponding to
##'   `object$term` and `object$by`. The `by` variable
##'   must be the last element.
##' @param knots a list containing any knots supplied for basis setup
##'   in same order and with same names as `data`. Cannot be
##'   `NULL`.
##' @return An object of class "fb.smooth", containing the elements of a
##'   smooth class documented under [mgcv::smooth.construct()].
##' @importFrom mgcv smooth.construct
##' @export
smooth.construct.fr.smooth.spec <- function(object,data,knots) {

  if(length(object$term)!=1L)
    stop("Basis only handles 1D smooths")
  x <- data[[object$term]]
  nx <- length(x)
  k <- sort(knots[[object$term]])
  nk <- length(k)

  if(nk<=3L) stop("At least 3 knots must be supplied")
  object$bs.dim <- nk

  h <- k[-1L]-k[-nk]
  F <- solve(makeBfr(h),makeDfr(h))
  j <- findInterval(x,k,all.inside=TRUE)
  X <- matrix(0,nx,nk)
  X[cbind(seq_len(nx),j)] <- (k[j+1L]-x)/h[j]
  X[cbind(seq_len(nx),j+1L)] <- (x-k[j])/h[j]
  cm <- ((k[j+1L]-x)^3/h[j]-h[j]*(k[j+1L]-x))/6
  cp <- ifelse(x < k[1L],0,(x-k[j])^3/(6*h[j]))-h[j]*(x-k[j])/6
  X <- X+cm*F[j,]+cp*F[j+1L,]

  object$X <- X
  object$S <- list()
  if(!object$fixed) {
    object$S[[1L]] <- t(F)%*%makeK(h)%*%F
  }
  object$rank <- nk-2L
  object$null.space.dim <- 2L
  object$knots <- k
  object$df <- ncol(object$X)
  class(object) <- "fr.smooth"
  object
}

##' A method for [mgcv::Predict.matrix()] for penalized cubic
##' regression splines smooths.
##'
##' This method constructs a prediction matrix for penalized cubic
##' regression splines smooths constrained to have zero first
##' derivative at the rightmost knot.
##'
##' @title GAM Predict Matrix Method
##' @param object a smooth object, usually generated by a
##'   [mgcv::smooth.construct()] method having processed a smooth
##'   specification object generated by an [mgcv::s()] or
##'   [mgcv::te()] term in a [mgcv::gam()] formula.
##' @param data A data frame containing the values of the (named)
##'   covariates at which the smooth term is to be evaluated. Exact
##'   requirements are as for [mgcv::smooth.construct()]
##' @return A matrix mapping the coefficients for the smooth term to its
##'   values at the supplied data values.
##' @importFrom mgcv Predict.matrix
##' @export
Predict.matrix.fr.smooth <- function(object,data) {

  x <- data[[object$term]]
  nx <- length(x)
  k <- object$knots
  nk <- length(k)

  h <- k[-1L]-k[-nk]
  F <- solve(makeBfr(h),makeDfr(h))
  j <- findInterval(x,k,all.inside=TRUE)
  X <- matrix(0,nx,nk)
  X[cbind(seq_len(nx),j)] <- (k[j+1L]-x)/h[j]
  X[cbind(seq_len(nx),j+1L)] <- (x-k[j])/h[j]
  cm <- ((k[j+1L]-x)^3/h[j]-h[j]*(k[j+1L]-x))/6
  cp <- ifelse(x < k[1L],0,(x-k[j])^3/(6*h[j]))-h[j]*(x-k[j])/6
  X <- X+cm*F[j,]+cp*F[j+1L,]
  X
}


##' Penalized cubic regression splines constrained to have zero first
##' derivative at the rightmost knot.
##'
##' These smooths are similar to the standard "cr" smooths, except
##' that the first derivative is constrained to be zero at the
##' rightmost knot. Because the location at which the derivative
##' constraint is applied is determined by the knots, the knots cannot
##' be automatically chosen and must be supplied by the user.
##'
##' Similar to the unconstrained case, the penalty smooth in the
##' presence of constraints on the first derivative can be shown to be
##' a cubic spline but with discontinuities in the second derivative
##' at the points where the derivative constraints apply.  So the
##' smooth will be a cubic spline within the interval spanned by the
##' knots, will be linear outside this interval and have
##' discontinuous second derivatives on the right boundary.
##'
##' @title Flat Right End Penalized Cubic Regression Splines
##' @param object a smooth specification object, usually generated by
##'   a term `s(...,bs="fl",...)`
##' @param data a list containing just the data (including any by
##'   variable) required by this term, with names corresponding to
##'   `object$term` and `object$by`. The `by` variable
##'   must be the last element.
##' @param knots a list containing any knots supplied for basis setup
##'   in same order and with same names as `data`. Cannot be
##'   `NULL`.
##' @return An object of class "fb.smooth", containing the elements of a
##'   smooth class documented under [mgcv::smooth.construct()].
##' @importFrom mgcv smooth.construct
##' @export
smooth.construct.zr.smooth.spec <- function(object,data,knots) {

  if(length(object$term)!=1L)
    stop("Basis only handles 1D smooths")
  x <- data[[object$term]]
  nx <- length(x)
  k <- sort(knots[[object$term]])
  nk <- length(k)

  if(nk<=3L) stop("At least 3 knots must be supplied")
  object$bs.dim <- nk

  h <- k[-1L]-k[-nk]
  F <- solve(makeBfr(h),makeDfr(h))
  j <- findInterval(x,k,all.inside=TRUE)
  X <- matrix(0,nx,nk)
  x <- pmin(k[nk],x)
  X[cbind(seq_len(nx),j)] <- (k[j+1L]-x)/h[j]
  X[cbind(seq_len(nx),j+1L)] <- (x-k[j])/h[j]
  cm <- ((k[j+1L]-x)^3/h[j]-h[j]*(k[j+1L]-x))/6
  cp <- ifelse(x < k[1L],0,(x-k[j])^3/(6*h[j]))-h[j]*(x-k[j])/6
  X <- X+cm*F[j,]+cp*F[j+1L,]

  object$X <- X
  object$S <- list()
  if(!object$fixed) {
    object$S[[1L]] <- t(F)%*%makeK(h)%*%F
  }
  object$rank <- nk-2L
  object$null.space.dim <- 2L
  object$knots <- k
  object$df <- ncol(object$X)
  class(object) <- "zr.smooth"
  object
}

##' A method for [mgcv::Predict.matrix()] for penalized cubic
##' regression splines smooths.
##'
##' This method constructs a prediction matrix for penalized cubic
##' regression splines smooths constrained to have zero first
##' derivative at the rightmost knot.
##'
##' @title GAM Predict Matrix Method
##' @param object a smooth object, usually generated by a
##'   [mgcv::smooth.construct()] method having processed a smooth
##'   specification object generated by an [mgcv::s()] or
##'   [mgcv::te()] term in a [mgcv::gam()] formula.
##' @param data A data frame containing the values of the (named)
##'   covariates at which the smooth term is to be evaluated. Exact
##'   requirements are as for [mgcv::smooth.construct()]
##' @return A matrix mapping the coefficients for the smooth term to its
##'   values at the supplied data values.
##' @importFrom mgcv Predict.matrix
##' @export
Predict.matrix.zr.smooth <- function(object,data) {

  x <- data[[object$term]]
  nx <- length(x)
  k <- object$knots
  nk <- length(k)

  h <- k[-1L]-k[-nk]
  F <- solve(makeBfr(h),makeDfr(h))
  j <- findInterval(x,k,all.inside=TRUE)
  X <- matrix(0,nx,nk)
  x <- pmin(k[nk],x)
  X[cbind(seq_len(nx),j)] <- (k[j+1L]-x)/h[j]
  X[cbind(seq_len(nx),j+1L)] <- (x-k[j])/h[j]
  cm <- ((k[j+1L]-x)^3/h[j]-h[j]*(k[j+1L]-x))/6
  cp <- ifelse(x < k[1L],0,(x-k[j])^3/(6*h[j]))-h[j]*(x-k[j])/6
  X <- X+cm*F[j,]+cp*F[j+1L,]
  X
}
